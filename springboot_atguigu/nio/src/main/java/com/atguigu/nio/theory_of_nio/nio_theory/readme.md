当前该包下的代码主要针对前两个包所展示出来的问题做一个解决方案,同时也是NIO的实现思路(针对服务端)
只是思路,而不是代码原理以及深层次的源码分析
1. 想要用比较少的线程实现所有连接的并发通信(在当前包下的代码是一个线程,即单线程实现所有连接的并发通信)
2. 但是想要用单线程实现所有连接的并发通信, 问题就在于监听连接建立的accept方法和读取客户端数据的read方法被堵塞了;而一旦线程被堵塞了就无法做其他事情
3. 所以问题的解决思路在于要不让accept方法和read方法堵塞线程
4. 假设现在调用accept方法和read方法不会堵塞线程(具体怎么实现目前不清楚,后续再补充,这里只是NIO的实现思路);那么最外层的while(true)循环就能不断的遍历, 每一次遍历都能够调用accept方法和read方法,如果有新的连接要建立那就建立新的连接,如果read方法就绪那就去读取数据;这样就能实现单个线程同时处理并发的连接建立和数据读取任务了.
5. 另外对于建立好的Socket(连接)要保存在一个list里面,以便于线程去遍历list里面的连接的read事件是否就绪
6. 总体思路就是: 非阻塞 + 存放Socket的list
7. 在代码中利用部分NIO的类来实现以上的思路.