当前该包下的代码主要针对前两个包所展示出来的问题做一个解决方案,同时也是NIO的实现思路(针对服务端)
只是思路,而不是代码原理以及深层次的源码分析
1. 想要用比较少的线程实现所有连接的并发通信(在当前包下的代码是一个线程,即单线程实现所有连接的并发通信)
2. 但是想要用单线程实现所有连接的并发通信, 问题就在于监听连接建立的accept方法和读取客户端数据的read方法被堵塞了;而一旦线程被堵塞了就无法做其他事情
3. 所以问题的解决思路在于要不让accept方法和read方法堵塞线程
4. 假设现在调用accept方法和read方法不会堵塞线程(具体底层怎么实现目前不清楚,后续再补充,这里只是NIO的实现思路);那么最外层的while(true)循环就能不断的遍历, 每一次遍历都能够调用accept方法和read方法,如果有新的连接要建立那就建立新的连接,如果read方法就绪那就去读取数据;这样就能实现单个线程同时处理并发的连接建立和数据读取任务了.
5. 另外对于建立好的Socket(连接)要保存在一个list里面,以便于线程去遍历list里面的连接的read事件是否就绪
6. 总体思路就是: 非阻塞 + 存放Socket的list
7. 在代码中利用部分NIO的类来实现以上的思路.
8. 但是这样实现的NIO会有几个弊端,就是当这个list过大的时候,每次都要遍历这个list,要检查这个list里面的每个socket的数据是否完成
   * 而检查socket数据的操作要从用户态切换到内核态,当list数量过大时会造成频繁的切换状态,导致性能下降
   * 并且有可能遍历完整个list也没有数据到达, 白白遍历了整个list
   * 另外有可能真正需要读写数据的Socket在最后一个, 但是还是要遍历完list前面素所有的Socket才能对最后一个Socket进行读写